# Copyright (C) 2025 ANSYS, Inc. and/or its affiliates.
# SPDX-License-Identifier: MIT
#
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# generated by datamodel-codegen

from __future__ import annotations

from enum import Enum
from typing import Any

from pydantic import AnyUrl, AwareDatetime, BaseModel, ConfigDict, Field, conint


class AuthRedirectRequestBody(BaseModel):
    pass
    model_config = ConfigDict(
        extra="allow",
    )


class AuthTokenResponseBody(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    token: str


class BinaryInfo(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    name: str
    platform: str
    size: int
    type: str


class BuildInfo(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    architecture: str | None = None
    branch: str | None = None
    go_version: str | None = None
    mode: str | None = None
    operating_system: str | None = None
    revision: str | None = None
    short_revision: str | None = None
    timestamp: str | None = None
    version: str | None = None
    version_hash: str | None = None


class CheckPermissionsResponse(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    allowed: bool = Field(..., description="Indicates if the check was successful")


class CompatBackend(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    name: str
    obj_type: str
    priority: int
    reference: str
    url: str
    use_default_url: bool


class CompatBuildInfo(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    branch: str
    revision: str
    short_revision: str
    timestamp: str
    version: str


class CompatCopyRequestBody(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    destination: str


class CompatCopyResponseBody(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    checksum: str


class CompatHealthResponseBody(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    ansft: bool
    build: CompatBuildInfo


class CompatStorageResponseBody(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    backends: list[CompatBackend] | None


class CompatUploadResponseBody(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    checksum: str


class DataAssignment(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    compressed_size: conint(ge=0) | None = None
    compression: str | None = None
    custom: dict[str, Any] | None = None
    uncompressed_size: conint(ge=0) | None = None


class ErrorDetail(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    location: str | None = Field(
        default=None,
        description="Where the error occurred, e.g. 'body.items[3].tags' or 'path.thing-id'",
    )
    message: str | None = Field(default=None, description="Error message text")
    value: Any | None = Field(default=None, description="The value at the given location")


class ErrorModel(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    detail: str | None = Field(
        default=None,
        description="A human-readable explanation specific to this occurrence of the problem.",
        examples=["Property foo is required but is missing."],
    )
    errors: list[ErrorDetail] | None = Field(default=None, description="Optional list of individual error details")
    instance: AnyUrl | None = Field(
        default=None,
        description="A URI reference that identifies the specific occurrence of the problem.",
        examples=["https://example.com/error-log/abc123"],
    )
    status: int | None = Field(default=None, description="HTTP status code", examples=[400])
    title: str | None = Field(
        default=None,
        description="A short, human-readable summary of the problem type. This value should not change between occurrences of the error.",
        examples=["Bad Request"],
    )
    type: AnyUrl | None = Field(
        default="about:blank",
        description="A URI reference to human-readable documentation for the error.",
        examples=["https://example.com/errors/example"],
    )


class Features(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    auth_types: list[str] | None = None
    compression_plugins: list[str] | None = None
    metadata_plugins: list[str] | None = None
    operation_plugins: list[str] | None = None
    permissions_plugins: list[str] | None = None
    storage_plugins: list[str] | None = None


class FileDownloadTokenResponseBody(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    token: str


class ListBinariesResponseBody(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    available: list[BinaryInfo] | None


class OperationState(Enum):
    Unknown = "unknown"
    Queued = "queued"
    Running = "running"
    Succeeded = "succeeded"
    Failed = "failed"


class Operation(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    children: list[str] | None
    children_detail: list[Operation] | None = None
    description: str
    ended_at: AwareDatetime
    error: str
    id: str
    info: dict[str, Any] | None = None
    messages: list[str] | None
    progress: float
    progress_current: conint(ge=0)
    progress_total: conint(ge=0)
    queued_at: AwareDatetime
    rate: str
    result: Any
    started_at: AwareDatetime
    state: OperationState
    succeeded_on: list[str] | None
    user_id: str


class OperationIdResponse(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    id: str = Field(..., description="ID of the operation", examples=["2diK2kCkpgeHAQSNthIZ1JYyPte"])
    location: str = Field(
        ...,
        description="Location to poll for operation status, provided in the body for convenience",
        examples=["/api/v1/operations/2diK2kCkpgeHAQSNthIZ1JYyPte"],
    )


class OperationsRequest(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    ids: list[str] | None = Field(..., description="List of operation IDs to retrieve")


class OperationsResponse(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    operations: list[Operation] | None


class PlainSrcDst(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    dst: str
    src: str


class RemoveMetadataRequest(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    paths: list[str] | None = Field(..., description="Paths to remove metadata for")
    recursive: bool = Field(..., description="Whether to remove metadata recursively")


class ResourceType(Enum):
    Document = "document"


class Resource(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    path: str = Field(..., examples=["my/path/to/data/file.txt"])
    type: ResourceType = Field(..., examples=["document"])


class SetMetadataRequest(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    metadata: dict[str, DataAssignment] = Field(..., description="Per-path metadata to set")


class StatusResponse(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    build_info: BuildInfo | None = Field(default=None, description="Information about the build")
    features: Features | None = Field(default=None, description="List of features and plugins available in the server")
    ready: bool | None = Field(default=None, description="Indicates if the server is ready to accept requests")
    time: str | None = Field(default=None, description="Current server time")


class StorageConfigResponse(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    storage: list[Any] | None = None


class StoragePath(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    path: str
    remote: str = "any"


class SubjectType(Enum):
    User = "user"
    Group = "group"
    Any = "any"


class Subject(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    id: str = Field(..., examples=["946991ec-828c-4de4-acbe-962ada8bc441"])
    type: SubjectType = Field(..., examples=["user"])


class TokenRequest(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    other: dict[str, Any] | None = None
    read: list[str] | None
    recursive: bool
    type: str
    write: list[str] | None


class UserCredentials(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    name: str
    password: str


class UserInfo(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    account_id: str
    groups: list[str] | None
    id: str
    is_admin: bool
    roles: list[str] | None
    service_admin: bool
    username: str


class WhoamiResponse(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    user: UserInfo


class WorkerConfig(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    auth: dict[str, Any] | None = None
    compression: dict[str, Any] | None = None
    metadata: dict[str, Any] | None = None
    permissions: dict[str, Any] | None = None
    storage: list[Any] | None = None
    user_id: str | None = None


class WorkerResetResponseBody(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    message: str


class WorkerTokenResponseBody(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    expires_at: AwareDatetime
    token: str


class AuthTokenRequestBody(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    credentials: UserCredentials


class CopyMetadataRequest(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    recursive: bool = Field(..., description="Whether to copy metadata recursively")
    src_dst: list[PlainSrcDst] | None = Field(..., description="Sources and destinations for the copy")


class GetMetadataRequest(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    operations: list[StoragePath] | None = Field(default=None, description="Deprecated as of 2024.09.10")
    paths: list[str] | None = Field(default=None, description="Paths to retrieve metadata for")


class MoveMetadataRequest(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    recursive: bool = Field(..., description="Whether to move metadata recursively")
    src_dst: list[PlainSrcDst] | None = Field(..., description="Sources and destinations for the move")


class PathOperations(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    operations: list[StoragePath] | None


class RoleAssignment(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    resource: Resource
    role: str = Field(..., examples=["reader"])
    subject: Subject


class RoleQuery(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    resource: Resource
    role: str | None = Field(default=None, examples=["reader"])
    subject: Subject


class SetPermissionsRequest(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    permissions: list[RoleAssignment] | None = Field(..., description="Permission definitions to set")


class SrcDst(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    dst: StoragePath
    src: StoragePath


class SrcDstOperations(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    operations: list[SrcDst] | None


class CheckPermissionsRequest(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    permissions: list[RoleAssignment] | None = Field(..., description="Permission to check for")


class GetPermissionsRequest(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    permissions: list[RoleQuery] | None = Field(..., description="Permission query to perform")


class GetPermissionsResponse(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    permissions: list[RoleAssignment] | None = Field(..., description="Permissions retrieved from the system")


class RemovePermissionsRequest(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    permissions: list[RoleAssignment] | None = Field(..., description="Permission to remove")


Operation.model_rebuild()
